"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var mobx_1 = require("mobx");
var inferno_component_1 = require("inferno-component");
var inferno_shared_1 = require("inferno-shared");
var EventEmitter_1 = require("./EventEmitter");
/**
 * Dev tools support
 */
var isDevtoolsEnabled = false;
exports.componentByNodeRegistery = new WeakMap();
exports.renderReporter = new EventEmitter_1.default();
function reportRendering(component) {
    var node = component._vNode.dom;
    if (node && exports.componentByNodeRegistery) {
        exports.componentByNodeRegistery.set(node, component);
    }
    exports.renderReporter.emit({
        event: 'render',
        renderTime: component.__$mobRenderEnd - component.__$mobRenderStart,
        totalTime: Date.now() - component.__$mobRenderStart,
        component: component,
        node: node
    });
}
function trackComponents() {
    if (typeof WeakMap === 'undefined') {
        inferno_shared_1.throwError('[inferno-mobx] tracking components is not supported in this browser.');
    }
    if (!isDevtoolsEnabled) {
        isDevtoolsEnabled = true;
    }
}
exports.trackComponents = trackComponents;
function makeReactive(componentClass) {
    var target = componentClass.prototype || componentClass;
    var baseDidMount = target.componentDidMount;
    var baseWillMount = target.componentWillMount;
    var baseUnmount = target.componentWillUnmount;
    target.componentWillMount = function () {
        var _this = this;
        // Call original
        baseWillMount && baseWillMount.call(this);
        var reaction;
        var isRenderingPending = false;
        var initialName = this.displayName || this.name || (this.constructor && (this.constructor.displayName || this.constructor.name)) || '<component>';
        var baseRender = this.render.bind(this);
        var initialRender = function (nextProps, nextContext) {
            reaction = new mobx_1.Reaction(initialName + ".render()", function () {
                if (!isRenderingPending) {
                    isRenderingPending = true;
                    if (_this.__$mobxIsUnmounted !== true) {
                        var hasError = true;
                        try {
                            inferno_component_1.default.prototype.forceUpdate.call(_this);
                            hasError = false;
                        }
                        finally {
                            if (hasError) {
                                reaction.dispose();
                            }
                        }
                    }
                }
            });
            reactiveRender.$mobx = reaction;
            _this.render = reactiveRender;
            return reactiveRender(nextProps, nextContext);
        };
        var reactiveRender = function (nextProps, nextContext) {
            isRenderingPending = false;
            var rendering = undefined;
            reaction.track(function () {
                if (isDevtoolsEnabled) {
                    _this.__$mobRenderStart = Date.now();
                }
                rendering = mobx_1.extras.allowStateChanges(false, baseRender.bind(_this, nextProps, nextContext));
                if (isDevtoolsEnabled) {
                    _this.__$mobRenderEnd = Date.now();
                }
            });
            return rendering;
        };
        this.render = initialRender;
    };
    target.componentDidMount = function () {
        isDevtoolsEnabled && reportRendering(this);
        // Call original
        baseDidMount && baseDidMount.call(this);
    };
    target.componentWillUnmount = function () {
        // Call original
        baseUnmount && baseUnmount.call(this);
        // Dispose observables
        this.render.$mobx && this.render.$mobx.dispose();
        this.__$mobxIsUnmounted = true;
        if (isDevtoolsEnabled) {
            var node = this._vNode.dom;
            if (node && exports.componentByNodeRegistery) {
                exports.componentByNodeRegistery.delete(node);
            }
            exports.renderReporter.emit({
                event: 'destroy',
                component: this,
                node: node
            });
        }
    };
    target.shouldComponentUpdate = function (nextProps, nextState) {
        // Update on any state changes (as is the default)
        if (this.state !== nextState) {
            return true;
        }
        // Update if props are shallowly not equal, inspired by PureRenderMixin
        var keys = Object.keys(this.props);
        if (keys.length !== Object.keys(nextProps).length) {
            return true;
        }
        for (var i = keys.length - 1; i >= 0; i--) {
            var key = keys[i];
            var newValue = nextProps[key];
            if (newValue !== this.props[key]) {
                return true;
            }
            else if (newValue && typeof newValue === 'object' && !mobx_1.isObservable(newValue)) {
                // If the newValue is still the same object, but that object is not observable,
                // fallback to the default behavior: update, because the object *might* have changed.
                return true;
            }
        }
        return true;
    };
    return componentClass;
}
exports.default = makeReactive;
