"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var hoist_non_inferno_statics_1 = require("hoist-non-inferno-statics");
var inferno_create_class_1 = require("inferno-create-class");
var inferno_create_element_1 = require("inferno-create-element");
/**
 * Store Injection
 */
function createStoreInjector(grabStoresFn, component) {
    var Injector = inferno_create_class_1.default({
        displayName: component.name,
        render: function () {
            var _this = this;
            var newProps = {};
            for (var key in this.props) {
                if (this.props.hasOwnProperty(key)) {
                    newProps[key] = this.props[key];
                }
            }
            var additionalProps = grabStoresFn(this.context.mobxStores || {}, newProps, this.context) || {};
            for (var key in additionalProps) {
                newProps[key] = additionalProps[key];
            }
            newProps.ref = function (instance) {
                _this.wrappedInstance = instance;
            };
            return inferno_create_element_1.default(component, newProps);
        }
    });
    Injector.contextTypes = { mobxStores: function () { } };
    hoist_non_inferno_statics_1.default(Injector, component);
    return Injector;
}
var grabStoresByName = function (storeNames) {
    return function (baseStores, nextProps) {
        storeNames.forEach(function (storeName) {
            // Prefer props over stores
            if (storeName in nextProps) {
                return;
            }
            if (!(storeName in baseStores)) {
                throw new Error("MobX observer: Store \"" + storeName + "\" is not available! " +
                    "Make sure it is provided by some Provider");
            }
            nextProps[storeName] = baseStores[storeName];
        });
        return nextProps;
    };
};
/**
 * Higher order component that injects stores to a child.
 * takes either a varargs list of strings, which are stores read from the context,
 * or a function that manually maps the available stores from the context to props:
 * storesToProps(mobxStores, props, context) => newProps
 */
function inject(grabStoresFn) {
    if (typeof grabStoresFn !== 'function') {
        var storesNames = [];
        for (var i = 0, len = arguments.length; i < len; i++) {
            storesNames[i] = arguments[i];
        }
        grabStoresFn = grabStoresByName(storesNames);
    }
    return function (componentClass) { return createStoreInjector(grabStoresFn, componentClass); };
}
exports.default = inject;
