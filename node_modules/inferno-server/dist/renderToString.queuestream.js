"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var inferno_shared_1 = require("inferno-shared");
var stream_1 = require("stream");
var inferno_1 = require("inferno");
var utils_1 = require("./utils");
function renderStylesToString(styles) {
    if (inferno_shared_1.isStringOrNumber(styles)) {
        return styles;
    }
    else {
        var renderedString = '';
        for (var styleName in styles) {
            var value = styles[styleName];
            var px = inferno_shared_1.isNumber(value) && !inferno_1.internal_isUnitlessNumber[styleName] ? 'px' : '';
            if (!inferno_shared_1.isNullOrUndef(value)) {
                renderedString += utils_1.toHyphenCase(styleName) + ":" + utils_1.escapeText(value) + px + ";";
            }
        }
        return renderedString;
    }
}
var RenderQueueStream = (function (_super) {
    __extends(RenderQueueStream, _super);
    function RenderQueueStream(initNode, staticMarkup) {
        var _this = _super.call(this) || this;
        _this.started = false;
        _this.collector = [Infinity]; // Infinity marks the end of the stream
        _this.promises = [];
        _this.pushQueue = _this.pushQueue.bind(_this);
        if (initNode) {
            _this.renderVNodeToQueue(initNode, null, staticMarkup, null);
        }
        return _this;
    }
    RenderQueueStream.prototype._read = function () {
        setTimeout(this.pushQueue, 0);
    };
    RenderQueueStream.prototype.addToQueue = function (node, position) {
        // Positioning defined, stack it
        if (!inferno_shared_1.isNullOrUndef(position)) {
            var lastSlot = this.promises[position].length - 1;
            // Combine as array or push into promise collector
            if (typeof this.promises[position][lastSlot] === 'string' &&
                typeof node === 'string') {
                this.promises[position][lastSlot] += node;
            }
            else {
                this.promises[position].push(node);
            }
            // Collector is empty push to stream
        }
        else if (typeof node === 'string' &&
            (this.collector.length - 1) === 0) {
            this.push(node);
            // Last element in collector and incoming are same then concat
        }
        else if (typeof node === 'string' &&
            typeof this.collector[this.collector.length - 2] === 'string') {
            this.collector[this.collector.length - 2] += node;
            // Push the element to collector (before Infinity)
        }
        else {
            this.collector.splice(-1, 0, node);
        }
    };
    RenderQueueStream.prototype.pushQueue = function () {
        var chunk = this.collector[0];
        // Output strings directly
        if (typeof chunk === 'string') {
            this.push(chunk);
            this.collector.shift();
            // For fulfilled promises, merge into collector
        }
        else if (!!chunk &&
            (typeof chunk === 'object' || inferno_shared_1.isFunction(chunk)) &&
            inferno_shared_1.isFunction(chunk.then)) {
            var self_1 = this;
            chunk.then(function (index) {
                (_a = self_1.collector).splice.apply(_a, [0, 1].concat(self_1.promises[index]));
                self_1.promises[index] = null;
                setTimeout(self_1.pushQueue, 0);
                var _a;
            });
            this.collector[0] = null;
            // End of content
        }
        else if (chunk === Infinity) {
            this.emit('end');
        }
    };
    RenderQueueStream.prototype.renderVNodeToQueue = function (vNode, context, firstChild, position) {
        var _this = this;
        // In case render returns invalid stuff
        if (inferno_shared_1.isInvalid(vNode)) {
            this.addToQueue('<!--!-->', position);
            return;
        }
        var flags = vNode.flags;
        var type = vNode.type;
        var props = vNode.props || inferno_1.EMPTY_OBJ;
        var children = vNode.children;
        // Handles a component render
        if (flags & 28 /* Component */) {
            var isClass = flags & 4 /* ComponentClass */;
            // Render the
            if (isClass) {
                var instance_1 = new type(props, context);
                var childContext = void 0;
                if (!inferno_shared_1.isUndefined(instance_1.getChildContext)) {
                    childContext = instance_1.getChildContext();
                }
                if (!inferno_shared_1.isNullOrUndef(childContext)) {
                    context = inferno_shared_1.combineFrom(context, childContext);
                }
                if (instance_1.props === inferno_1.EMPTY_OBJ) {
                    instance_1.props = props;
                }
                instance_1.context = context;
                instance_1._pendingSetState = true;
                instance_1._unmounted = false;
                // Trigger lifecycle hook
                if (inferno_shared_1.isFunction(instance_1.componentWillMount)) {
                    instance_1.componentWillMount();
                }
                // Trigger extra promise-based lifecycle hook
                if (inferno_shared_1.isFunction(instance_1.getInitialProps)) {
                    var initialProps = instance_1.getInitialProps(instance_1.props, instance_1.context);
                    if (initialProps) {
                        if (Promise.resolve(initialProps) === initialProps) {
                            var promisePosition_1 = this.promises.push([]) - 1;
                            this.addToQueue(initialProps.then(function (dataForContext) {
                                instance_1._pendingSetState = false;
                                if (typeof dataForContext === 'object') {
                                    instance_1.props = inferno_shared_1.combineFrom(instance_1.props, dataForContext);
                                }
                                _this.renderVNodeToQueue(instance_1.render(instance_1.props, instance_1.context), instance_1.context, true, promisePosition_1);
                                setTimeout(_this.pushQueue, 0);
                                return promisePosition_1;
                            }), position);
                            return;
                        }
                        else {
                            instance_1.props = inferno_shared_1.combineFrom(instance_1.props, initialProps);
                        }
                    }
                }
                var nextVNode = instance_1.render(props, vNode.context);
                instance_1._pendingSetState = false;
                this.renderVNodeToQueue(nextVNode, context, true, position);
            }
            else {
                var nextVNode = type(props, context);
                this.renderVNodeToQueue(nextVNode, context, true, position);
            }
            // If an element
        }
        else if (flags & 3970 /* Element */) {
            var renderedString = "<" + type;
            var html = void 0;
            var isVoidElement = utils_1.isVoidElement(type);
            if (!inferno_shared_1.isNull(props)) {
                for (var prop in props) {
                    var value = props[prop];
                    if (prop === 'dangerouslySetInnerHTML') {
                        html = value.__html;
                    }
                    else if (prop === 'style') {
                        renderedString += " style=\"" + renderStylesToString(props.style) + "\"";
                    }
                    else if (prop === 'className' && !inferno_shared_1.isNullOrUndef(value)) {
                        renderedString += " class=\"" + utils_1.escapeText(value) + "\"";
                    }
                    else if (prop === 'children') {
                        // Ignore children as prop.
                    }
                    else if (prop === 'defaultValue') {
                        // Use default values if normal values are not present
                        if (!props.value) {
                            renderedString += " value=\"" + utils_1.escapeText(value) + "\"";
                        }
                    }
                    else if (prop === 'defaultChecked') {
                        // Use default values if normal values are not present
                        if (!props.checked) {
                            renderedString += " checked=\"" + value + "\"";
                        }
                    }
                    else {
                        if (inferno_shared_1.isStringOrNumber(value)) {
                            renderedString += " " + prop + "=\"" + utils_1.escapeText(value) + "\"";
                        }
                        else if (inferno_shared_1.isTrue(value)) {
                            renderedString += " " + prop;
                        }
                    }
                }
            }
            // Voided element, push directly to queue
            if (isVoidElement) {
                this.addToQueue(renderedString + ">", position);
                // Regular element with content
            }
            else {
                renderedString += ">";
                // Element has children, build them in
                if (!inferno_shared_1.isInvalid(children)) {
                    if (inferno_shared_1.isArray(children)) {
                        this.addToQueue(renderedString, position);
                        renderedString = '';
                        for (var i = 0, len = children.length; i < len; i++) {
                            var child = children[i];
                            if (inferno_shared_1.isStringOrNumber(child)) {
                                this.addToQueue(utils_1.escapeText(children), position);
                            }
                            else if (!inferno_shared_1.isInvalid(child)) {
                                this.renderVNodeToQueue(child, context, i === 0, position);
                            }
                        }
                    }
                    else if (inferno_shared_1.isStringOrNumber(children)) {
                        this.addToQueue(renderedString + utils_1.escapeText(children) + '</' + type + '>', position);
                        return;
                    }
                    else {
                        this.addToQueue(renderedString, position);
                        this.renderVNodeToQueue(children, context, true, position);
                        this.addToQueue('</' + type + '>', position);
                        return;
                    }
                }
                else if (html) {
                    this.addToQueue(renderedString + html + '</' + type + '>', position);
                    return;
                }
                // Close element if it's not void
                if (!isVoidElement) {
                    this.addToQueue(renderedString + '</' + type + '>', position);
                }
            }
            // Push text directly to queue
        }
        else if (flags & 1 /* Text */) {
            this.addToQueue((firstChild ? '' : '<!---->') + utils_1.escapeText(children), position);
            // Handle errors
        }
        else {
            if (process.env.NODE_ENV !== 'production') {
                if (typeof vNode === 'object') {
                    inferno_shared_1.throwError("renderToString() received an object that's not a valid VNode, you should stringify it first. Object: \"" + JSON.stringify(vNode) + "\".");
                }
                else {
                    inferno_shared_1.throwError("renderToString() expects a valid VNode, instead it received an object with the type \"" + typeof vNode + "\".");
                }
            }
            inferno_shared_1.throwError();
        }
    };
    return RenderQueueStream;
}(stream_1.Readable));
exports.RenderQueueStream = RenderQueueStream;
function streamQueueAsString(node) {
    return new RenderQueueStream(node, false);
}
exports.default = streamQueueAsString;
function streamQueueAsStaticMarkup(node) {
    return new RenderQueueStream(node, true);
}
exports.streamQueueAsStaticMarkup = streamQueueAsStaticMarkup;
